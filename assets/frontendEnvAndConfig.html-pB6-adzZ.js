import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as a,o as i}from"./app-DMVMUeoW.js";const l={};function d(t,s){return i(),e("div",null,[...s[0]||(s[0]=[a(`<h1 id="前端容器化配置注入全攻略-docker-k8s-🐳🚀" tabindex="-1"><a class="header-anchor" href="#前端容器化配置注入全攻略-docker-k8s-🐳🚀"><span>前端容器化配置注入全攻略（docker/k8s） 🐳🚀</span></a></h1><p>如果你的前端应用经常需要修改配置，是否想过像后端一样预留一个配置文件方便修改就好了，介绍几种配置注入的方式，还有K8s的相关配置.</p><p>最近和一个团队合作，看到他们团队用了Node起了个BFF层，结合K8s提供了一些配置给前端，研究了一下主流的几种提供配置给前端的方式，在前端项目中，无论是 Node 服务还是 Nginx 托管的 SPA，<strong>环境配置</strong>都是必须面对的问题。这里总结了几种主流方式，把配置注入到前端应用中，并结合 <strong>Docker 构建</strong>和 <strong>Kubernetes ConfigMap</strong>，整理成两大类：<strong>构建时注入</strong>和<strong>运行时注入</strong>.</p><hr><h2 id="一、构建时注入-🛠️" tabindex="-1"><a class="header-anchor" href="#一、构建时注入-🛠️"><span>一、构建时注入 🛠️</span></a></h2><p>构建时注入的核心思想是：<strong>配置在构建镜像时就已经确定</strong>。这种方式灵活性稍差，但实现简单</p><h3 id="_1-1-环境变量注入-env-方式" tabindex="-1"><a class="header-anchor" href="#_1-1-环境变量注入-env-方式"><span>1.1 环境变量注入（Env 方式）</span></a></h3><p>Dockerfile 示例：</p><p>（这里纯前端无Node服务的话，只需要写VITE_MODE，不需要写NODE_ENV，Vite会根据Vite Mode来改变NODE_ENV）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>FROM node:20-alpine AS build-stage</span></span>
<span class="line"><span>WORKDIR /app</span></span>
<span class="line"><span></span></span>
<span class="line"><span>COPY . .</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 使用不同的 Vite 模式</span></span>
<span class="line"><span>ARG VITE_MODE=production</span></span>
<span class="line"><span>RUN pnpm run build:\${VITE_MODE}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CMD [&quot;node&quot;, &quot;server/index.js&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CI/CD 构建示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>script:</span></span>
<span class="line"><span>  - |</span></span>
<span class="line"><span>    if [ &quot;$BRANCH&quot; == &quot;main&quot; ]; then</span></span>
<span class="line"><span>      VITE_MODE=prod</span></span>
<span class="line"><span>    elif [ &quot;$BRANCH&quot; == &quot;staging&quot; ]; then</span></span>
<span class="line"><span>      VITE_MODE=staging</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>      VITE_MODE=dev</span></span>
<span class="line"><span>    fi</span></span>
<span class="line"><span>  - docker build --build-arg NODE_ENV=\${NODE_ENV} --build-arg VITE_MODE=\${VITE_MODE} -t myapp:\${VITE_MODE} .</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 说明：构建时环境变量直接写进镜像，无法在运行时修改</p></blockquote><hr><h3 id="_1-2-标签注入-tag-方式" tabindex="-1"><a class="header-anchor" href="#_1-2-标签注入-tag-方式"><span>1.2 标签注入（Tag 方式）</span></a></h3><p>有时我们希望镜像带上构建信息，如 Git SHA 或分支名：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>docker build -t myapp:dev-$(git rev-parse --short HEAD) .</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样镜像名称就自带版本信息，方便部署和回滚</p><hr><h3 id="_1-3-html-内嵌配置-label-或-script" tabindex="-1"><a class="header-anchor" href="#_1-3-html-内嵌配置-label-或-script"><span>1.3 HTML 内嵌配置（<code>&lt;label&gt;</code> 或 <code>&lt;script&gt;</code>）</span></a></h3><p>构建时注入 ，可以把配置信息直接写入HTML中：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>&lt;label id=&quot;STORE_INIT&quot; style=&quot;display:none;&quot;&gt;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;API_URL&quot;: &quot;http://api.example.com&quot;,</span></span>
<span class="line"><span>  &quot;APP_NAME&quot;: &quot;TEST_APP&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>&lt;/label&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前端读取：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>const config = JSON.parse(document.getElementById(&#39;CONFIG_WEB_STORE&#39;).innerText);</span></span>
<span class="line"><span>console.log(config.API_URL, config.APP_NAME);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>🎯 优点：初始化时直接可用，无需额外请求。 ❌ 缺点：构建后固定，不能动态修改。</p></blockquote><hr><h2 id="二、运行时注入-⚡" tabindex="-1"><a class="header-anchor" href="#二、运行时注入-⚡"><span>二、运行时注入 ⚡</span></a></h2><p>运行时注入的核心思想是：<strong>镜像不包含最终配置，配置在容器运行或 Pod 启动时注入</strong>。</p><h3 id="_2-1-json-配置文件-configmap" tabindex="-1"><a class="header-anchor" href="#_2-1-json-配置文件-configmap"><span>2.1 JSON 配置文件 + ConfigMap</span></a></h3><p>前端可以从 <code>/config/web.config.json</code> 获取配置，配合 Kubernetes ConfigMap：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;API_URL&quot;: &quot;http://api.example.com&quot;,</span></span>
<span class="line"><span>  &quot;APP_NAME&quot;: &quot;TEST_APP&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Deployment 示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>volumeMounts:</span></span>
<span class="line"><span>  - name: frontend-config</span></span>
<span class="line"><span>    mountPath: /usr/share/nginx/html/config</span></span>
<span class="line"><span>volumes:</span></span>
<span class="line"><span>  - name: frontend-config</span></span>
<span class="line"><span>    configMap:</span></span>
<span class="line"><span>      name: frontend-config</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Node 或 Nginx 服务都可以读取 JSON 文件，前端通过 <code>fetch</code> 获取：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>fetch(&#39;/config/web.config.json&#39;)</span></span>
<span class="line"><span>  .then(res =&gt; res.json())</span></span>
<span class="line"><span>  .then(cfg =&gt; console.log(cfg));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>✅ 优点：可以在运行时更新配置，无需重建镜像</p></blockquote><hr><h3 id="_2-2-node-vs-nginx" tabindex="-1"><a class="header-anchor" href="#_2-2-node-vs-nginx"><span>2.2 Node vs Nginx</span></a></h3><ul><li><strong>Node</strong>：直接读取挂载的 JSON 文件即可，容器内修改后无需重启服务（取决于服务实现）</li><li><strong>Nginx</strong>：静态文件服务，修改挂载文件后，需要重启 Nginx 或重启 Pod 才能生效</li></ul><blockquote><p>📝 小技巧：JSON 文件路径可通过 Dockerfile 的 <code>VOLUME</code> 或 Kubernetes <code>volumeMounts</code> 预留，让 ConfigMap 自动覆盖</p></blockquote><p>其实直接用Nginx是最稳妥的，BFF层很多时候并没有必要，都是后端的职能，后端提供了VO就没必要折腾了（99%的团队是用不上BFF的），因为我看到团队中的BFF层的作用基本就是提供了文件静态服务，提供了配置，就加入了一个node后端框架和服务，属实无必要，反而增加了程序复杂性，前端需要启动node服务才能跑起来，如无必要勿增实体。</p><hr><h2 id="三、小结-✨" tabindex="-1"><a class="header-anchor" href="#三、小结-✨"><span>三、小结 ✨</span></a></h2><table><thead><tr><th>类别</th><th>方式</th><th>注入时机</th><th>优缺点</th></tr></thead><tbody><tr><td>构建时注入</td><td>Env / VITE_MODE</td><td>镜像构建</td><td>简单，无法运行时修改</td></tr><tr><td>构建时注入</td><td>Tag</td><td>镜像构建</td><td>镜像带版本信息，方便回滚</td></tr><tr><td>构建时注入</td><td>HTML <code>&lt;label&gt;</code></td><td>页面生成</td><td>初始化直接可用，构建后固定</td></tr><tr><td>运行时注入</td><td>JSON + ConfigMap</td><td>容器启动</td><td>可动态修改，支持 k8s</td></tr></tbody></table><p>💡 总结经验：</p><ul><li><strong>开发环境</strong>：构建时注入 + 标签即可快速迭代</li><li><strong>生产环境</strong>：运行时注入 + ConfigMap，更灵活，方便运维</li></ul><p>当然，还可以让后端提供一个配置接口~ 这是最动态的了</p><hr><p><em><strong>END</strong></em></p><hr>`,50)])])}const o=n(l,[["render",d]]),c=JSON.parse('{"path":"/server/frontendEnvAndConfig.html","title":"前端容器化配置注入全攻略（docker/k8s） 🐳🚀","lang":"zh-CN","frontmatter":{},"git":{"createdTime":1759051185000,"updatedTime":1759051185000,"contributors":[{"name":"sharebravery","username":"sharebravery","email":"sharebravery@gmail.com","commits":1,"url":"https://github.com/sharebravery"}]},"readingTime":{"minutes":3.47,"words":1042},"filePathRelative":"server/frontendEnvAndConfig.md","excerpt":""}');export{o as comp,c as data};
