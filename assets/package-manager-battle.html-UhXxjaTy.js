import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as a,o}from"./app-DTQAk5n9.js";const p={};function d(r,t){return o(),n("div",null,[...t[0]||(t[0]=[a('<h1 id="包管理器的战国时代-npm-yarn-pnpm-与-bun" tabindex="-1"><a class="header-anchor" href="#包管理器的战国时代-npm-yarn-pnpm-与-bun"><span>包管理器的战国时代：npm, yarn, pnpm 与 Bun</span></a></h1><p>前端圈有个笑话：每过 18 个月，我们就得重学一遍怎么安装依赖。</p><p>从 <code>npm</code> 的嵌套地狱，到 <code>yarn</code> 的扁平化革命，再到 <code>pnpm</code> 的硬链接魔法，最后是 <code>Bun</code> 这个不讲武德的“快枪手”。我经常看着 <code>node_modules</code> 陷入沉思：</p><p><strong>我们到底是在写代码，还是在管理这些该死的包？</strong></p><p>昨天我想给一个老项目升个级，结果就在 <code>npm install</code> 这一步卡了半小时，不仅磁盘爆满，还因为 phantom dependency（幻影依赖）炸了一堆错。那一刻我真的想把电脑扔出窗外。</p><p>今天不聊虚的，就聊聊作为一个开发者，在这些工具的混战中，我们到底该选谁。</p><h2 id="_1-npm-那位年迈的老父亲" tabindex="-1"><a class="header-anchor" href="#_1-npm-那位年迈的老父亲"><span>1. npm：那位年迈的老父亲</span></a></h2><p><strong>核心槽点</strong>：慢，且重。</p><p>早期的 npm 就像是一个没有规划的仓库管理员。你今天让他进货（安装），明天让他进货，拿到的东西可能都不一样（版本号非确定性）。虽然现在有了 <code>package-lock.json</code>，但它的效率依然让人捉急。</p><p>最让我头疼的是它的“幻影依赖”。</p><p>有时候你明明没安装 A，但因为你的依赖 B 依赖了 A，你居然能直接在代码里 <code>import A</code>。这就像是你邻居买了辆车，你没买，但你居然能直接开他的车。等到哪天邻居搬走了（B 升级去掉了 A），你的代码瞬间炸了，你还一脸懵逼：我车呢？</p><h2 id="_2-yarn-v1-曾经的救世主" tabindex="-1"><a class="header-anchor" href="#_2-yarn-v1-曾经的救世主"><span>2. yarn (v1)：曾经的救世主</span></a></h2><p><strong>核心贡献</strong>：<code>yarn.lock</code> 和 并行安装。</p><p>当年 yarn 出来的时候，真的感觉是降维打击。原本 npm 要跑 5 分钟的 install，yarn 可能 1 分钟就搞定了。它就像是一个受过专业训练的物流团队，高效、精准。</p><p>但现在？yarn v1 已经停止维护了，v2/v3 的 PnP (Plug&#39;n&#39;Play) 模式步子迈得太大，把生态搞得有点分裂。我现在基本只在维护几年前的老项目时才会见到它，就像见到一位退役的老兵。</p><h2 id="_3-pnpm-磁盘救星" tabindex="-1"><a class="header-anchor" href="#_3-pnpm-磁盘救星"><span>3. pnpm：磁盘救星</span></a></h2><p><strong>核心洞察</strong>：为什么每个项目都要把 <code>react</code> 重新下载一遍？</p><p>pnpm 是我目前的<strong>主力推荐</strong>。它的逻辑非常硬核：</p><ol><li><strong>全局存储</strong>：所有项目的依赖都存在硬盘的同一个地方。</li><li><strong>硬链接 (Hard Links)</strong>：项目里的 <code>node_modules</code> 只是指向全局存储的链接。</li></ol><p>自从换了 pnpm，我的 MacBook 磁盘空间瞬间释放了几个 G。这感觉就像是你原本要在每个房间都买一台电视，现在只需要在一个房间买，其他房间装个镜子反射过去就行了。</p><p>而且它严格禁止了“幻影依赖”，你没安装的包绝对不能用。这种**“洁癖”**，深得我心。</p><h2 id="_4-bun-不讲武德的挑战者" tabindex="-1"><a class="header-anchor" href="#_4-bun-不讲武德的挑战者"><span>4. Bun：不讲武德的挑战者</span></a></h2><p><strong>核心优势</strong>：快，太快了。</p><p>Bun 不是一个简单的包管理器，它是一个全新的 Runtime。用 <code>bun install</code> 的速度，有时候快到让我怀疑它是不是在假装安装。</p><p>但老实说，我在生产环境还是不太敢全量上 Bun。它的兼容性虽然一直在变好，但偶尔遇到一些奇奇怪怪的 edge case，真的会让人修到怀疑人生。它就像是一个天才少年，跑得飞快，但有时候做事不太稳重。</p><h2 id="终极速查表" tabindex="-1"><a class="header-anchor" href="#终极速查表"><span>终极速查表</span></a></h2><p>既然还得干活，这里有一份我整理的“多语言翻译表”。脑容量有限，这种死记硬背的东西就交给文档吧。</p><table><thead><tr><th style="text-align:left;">动作</th><th style="text-align:left;">npm (经典)</th><th style="text-align:left;">yarn (老将)</th><th style="text-align:left;">pnpm (主力)</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>安装依赖</strong></td><td style="text-align:left;"><code>npm install</code></td><td style="text-align:left;"><code>yarn</code></td><td style="text-align:left;"><code>pnpm i</code></td><td style="text-align:left;">拿到新项目的第一件事</td></tr><tr><td style="text-align:left;"><strong>加个包</strong></td><td style="text-align:left;"><code>npm i package</code></td><td style="text-align:left;"><code>yarn add package</code></td><td style="text-align:left;"><code>pnpm add package</code></td><td style="text-align:left;">默认都是生产依赖</td></tr><tr><td style="text-align:left;"><strong>加个开发包</strong></td><td style="text-align:left;"><code>npm i -D package</code></td><td style="text-align:left;"><code>yarn add -D package</code></td><td style="text-align:left;"><code>pnpm add -D package</code></td><td style="text-align:left;">比如 TS, ESLint</td></tr><tr><td style="text-align:left;"><strong>移除包</strong></td><td style="text-align:left;"><code>npm uninstall pkg</code></td><td style="text-align:left;"><code>yarn remove pkg</code></td><td style="text-align:left;"><code>pnpm remove pkg</code></td><td style="text-align:left;">分手快乐</td></tr><tr><td style="text-align:left;"><strong>交互升级</strong></td><td style="text-align:left;">-</td><td style="text-align:left;"><code>upgrade-interactive</code></td><td style="text-align:left;"><code>pnpm up -i -L</code></td><td style="text-align:left;"><strong>神器！</strong> 像点菜一样选升级</td></tr><tr><td style="text-align:left;"><strong>查谁用了它</strong></td><td style="text-align:left;"><code>npm ls pkg</code></td><td style="text-align:left;"><code>yarn why pkg</code></td><td style="text-align:left;"><code>pnpm why pkg</code></td><td style="text-align:left;">抓出那个引入奇怪依赖的元凶</td></tr></tbody></table><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><ul><li>如果你是新项目：<strong>闭眼选 pnpm</strong>。</li><li>如果你想尝鲜且不怕折腾：<strong>试试 Bun</strong>。</li><li>如果你在维护祖传代码：<strong>Respect npm/yarn</strong>，别乱动，会炸。</li></ul><p>工具只是手段，代码才是目的。别在工具链上浪费太多生命，选个顺手的，然后去写那些真正改变世界的代码吧。</p><hr><p><em>END</em></p>',33)])])}const c=e(p,[["render",d]]),i=JSON.parse('{"path":"/tools/package-manager-battle.html","title":"包管理器的战国时代：npm, yarn, pnpm 与 Bun","lang":"zh-CN","frontmatter":{"title":"包管理器的战国时代：npm, yarn, pnpm 与 Bun","date":"2021-07-23T00:00:00.000Z","category":"效率工具","tag":["Tools","Node.js"],"description":"包管理器的战国时代：npm, yarn, pnpm 与 Bun 前端圈有个笑话：每过 18 个月，我们就得重学一遍怎么安装依赖。 从 npm 的嵌套地狱，到 yarn 的扁平化革命，再到 pnpm 的硬链接魔法，最后是 Bun 这个不讲武德的“快枪手”。我经常看着 node_modules 陷入沉思： 我们到底是在写代码，还是在管理这些该死的包？ 昨天...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"包管理器的战国时代：npm, yarn, pnpm 与 Bun\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-07-23T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-30T07:58:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"sharebravery\\",\\"url\\":\\"https://github.com/sharebravery\\"}]}"],["meta",{"property":"og:url","content":"https://sharebravery.github.io/tools/package-manager-battle.html"}],["meta",{"property":"og:site_name","content":"不辞远的分享"}],["meta",{"property":"og:title","content":"包管理器的战国时代：npm, yarn, pnpm 与 Bun"}],["meta",{"property":"og:description","content":"包管理器的战国时代：npm, yarn, pnpm 与 Bun 前端圈有个笑话：每过 18 个月，我们就得重学一遍怎么安装依赖。 从 npm 的嵌套地狱，到 yarn 的扁平化革命，再到 pnpm 的硬链接魔法，最后是 Bun 这个不讲武德的“快枪手”。我经常看着 node_modules 陷入沉思： 我们到底是在写代码，还是在管理这些该死的包？ 昨天..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2026-01-30T07:58:30.000Z"}],["meta",{"property":"article:tag","content":"Node.js"}],["meta",{"property":"article:tag","content":"Tools"}],["meta",{"property":"article:published_time","content":"2021-07-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-30T07:58:30.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://sharebravery.github.io/en/tools/package-manager-battle.html"}]]},"git":{"createdTime":1769332830000,"updatedTime":1769759910000,"contributors":[{"name":"sharebravery","username":"sharebravery","email":"sharebravery@gmail.com","commits":3,"url":"https://github.com/sharebravery"},{"name":"Claude Sonnet 4.5","username":"","email":"noreply@anthropic.com","commits":1}]},"readingTime":{"minutes":3.89,"words":1168},"filePathRelative":"tools/package-manager-battle.md","excerpt":"\\n<p>前端圈有个笑话：每过 18 个月，我们就得重学一遍怎么安装依赖。</p>\\n<p>从 <code>npm</code> 的嵌套地狱，到 <code>yarn</code> 的扁平化革命，再到 <code>pnpm</code> 的硬链接魔法，最后是 <code>Bun</code> 这个不讲武德的“快枪手”。我经常看着 <code>node_modules</code> 陷入沉思：</p>\\n<p><strong>我们到底是在写代码，还是在管理这些该死的包？</strong></p>\\n<p>昨天我想给一个老项目升个级，结果就在 <code>npm install</code> 这一步卡了半小时，不仅磁盘爆满，还因为 phantom dependency（幻影依赖）炸了一堆错。那一刻我真的想把电脑扔出窗外。</p>","autoDesc":true}');export{c as comp,i as data};
