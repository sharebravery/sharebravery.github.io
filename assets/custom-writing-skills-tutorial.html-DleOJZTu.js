import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as t}from"./app-zaYUK-qA.js";const e="/assets/01-framework-skill-formula-YZSh7AJ5.png",l="/assets/02-comparison-evolution-Cwr28s_p.png",r={};function p(o,s){return t(),i("div",null,[...s[0]||(s[0]=[n('<h1 id="提示词工程已死-agent-skills-才是未来" tabindex="-1"><a class="header-anchor" href="#提示词工程已死-agent-skills-才是未来"><span>提示词工程已死？Agent Skills 才是未来</span></a></h1><p>2023 年，&quot;Prompt Engineering&quot;（提示词工程）一度被奉为 AI 时代的必修课。那时候，我们像炼丹师一样，试图通过修改一个标点、调整一段语序，来祈求模型输出完美的结果。</p><p>但到了 2026 年的今天，这种做法显得越来越笨重，甚至有些<strong>不可持续</strong>。</p><p>仔细观察会发现，我们陷入了一个误区：我们花费大量精力去“适应”机器，试图用自然语言去模拟机器的逻辑。一旦模型更新，或者上下文环境改变，那些精心调教的 Prompt 往往会瞬间失效。</p><p>这不叫工程，这叫<strong>碰运气</strong>。</p><p>真正的未来，或许不在于写出更完美的 Prompt，而在于构建更稳健的 <strong>Skills (技能)</strong>。</p><h2 id="prompt-的本质缺陷" tabindex="-1"><a class="header-anchor" href="#prompt-的本质缺陷"><span>Prompt 的本质缺陷</span></a></h2><p>为什么 Prompt Engineering 难以规模化？因为它本质上是一种<strong>硬编码 (Hard-coding)</strong>。</p><p>在软件工程中，硬编码通常意味着脆弱和难以维护。Prompt 也是如此：</p><ol><li><strong>缺乏复用性</strong>：针对 GPT-4 优化的指令，扔给 Claude 可能完全跑偏。</li><li><strong>上下文割裂</strong>：每次对话都需要重复输入背景信息，效率极低。</li><li><strong>状态缺失</strong>：Prompt 是一次性的，它无法像对象一样保存状态或记忆偏好。</li></ol><p>当我们需要构建复杂的 AI 应用时，单纯的 Prompt 已经无法满足需求。我们需要从“脚本思维”进化到“对象思维”。</p><h2 id="什么是-skill" tabindex="-1"><a class="header-anchor" href="#什么是-skill"><span>什么是 Skill？</span></a></h2><p>在 Agentic Coding（代理编码）的语境下，Skill 不再是一段简单的文本，它更像是一个封装良好的<strong>对象 (Object)</strong>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>k</mi><mi>i</mi><mi>l</mi><mi>l</mi><mo>=</mo><mi>R</mi><mi>o</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mtext>角色卡</mtext><mo stretchy="false">)</mo><mo>+</mo><mi>R</mi><mi>u</mi><mi>l</mi><mi>e</mi><mi>b</mi><mi>o</mi><mi>o</mi><mi>k</mi><mo stretchy="false">(</mo><mtext>规则书</mtext><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">(</mo><mtext>上下文</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> Skill = Role (角色卡) + Rulebook (规则书) + Context (上下文) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord cjk_fallback">角色卡</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord cjk_fallback">规则书</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord cjk_fallback">上下文</span><span class="mclose">)</span></span></span></span></span></p><figure><img src="'+e+`" alt="Skill Framework Analysis" tabindex="0" loading="lazy"><figcaption>Skill Framework Analysis</figcaption></figure><ul><li><strong>Role (角色)</strong>：定义了它“是谁”。这类似于面向对象中的 <code>Class</code> 定义。</li><li><strong>Rulebook (规则书)</strong>：定义了它“能做什么”，以及更重要的“<strong>不能做什么</strong>”。这是它的接口 (<code>Interface</code>) 和约束。</li><li><strong>Context (上下文)</strong>：自动读取必要的环境信息（如项目结构、代码风格）。这是它的成员变量 (<code>Properties</code>)。</li></ul><p>这种封装带来的好处是显而易见的：我们把一头不可控的野兽（Raw LLM），训练成了一只可靠的导盲犬（Agent）。</p><h2 id="实战-打造一个-私人技术作家" tabindex="-1"><a class="header-anchor" href="#实战-打造一个-私人技术作家"><span>实战：打造一个“私人技术作家”</span></a></h2><p>为了更直观地理解 Skill 的价值，我们可以看一个真实的案例。</p><p>写技术博客时，我们常常面临一个困境：AI 生成的内容往往带有一种浓重的“AI 味”——四平八稳，充满了“总而言之”、“综上所述”这样的废话，缺乏独特的观点和风格。</p><p>如果用 Prompt Engineering 的思路，我们需要每次都输入一段几百字的指令来纠正它的语气。但这非常繁琐。</p><p>如果用 Skill 的思路，我们可以将这些要求固化下来，创建一个名为 <code>personal-tech-writer</code> 的技能。</p><h3 id="_1-结构化定义" tabindex="-1"><a class="header-anchor" href="#_1-结构化定义"><span>1. 结构化定义</span></a></h3><p>在这个 Skill 中，我们不再是“对话”，而是在“配置”：</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-yaml"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">---</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">personal-tech-writer</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">description</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Baoyu&#39;s writing persona (Pragmatic, Story-driven, Vulnerable).</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Rulebook (规则书)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 1. The Hook (切入点)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*   </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">*Don&#39;t**</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> start with definitions. Start with a phenomenon or a question.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*   </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">*Focus**:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Clarity and Narrative Flow.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 2. Tone (基调)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*   </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">*Objective**:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Avoid &quot;I think&quot; overuse. Focus on the insight itself.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*   </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">*Lucid**:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Explain complex concepts with simple analogies.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 3. Formatting (格式)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*   </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">*No</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> Emojis**</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Keep it clean.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*   </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">*Rhythm**:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Use breathable paragraphs.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-隐式上下文注入" tabindex="-1"><a class="header-anchor" href="#_2-隐式上下文注入"><span>2. 隐式上下文注入</span></a></h3><p>Skill 的核心优势在于<strong>上下文注入</strong>。</p><p>当调用 <code>/skill personal-tech-writer</code> 时，系统会自动加载预设的风格指南 (<code>style-guide.md</code>)。这就像是给浏览器安装了一个插件，或者给电脑安装了一个驱动程序。</p><p>AI 瞬间就“懂”了你的偏好。它不再试图讨好你，而是按照预设的规则，以一种清晰、流畅、有节奏感的方式进行输出。</p><p>这就是 <strong>Agent</strong> 的力量。</p><h2 id="从脚本到面向对象" tabindex="-1"><a class="header-anchor" href="#从脚本到面向对象"><span>从脚本到面向对象</span></a></h2><p>如果将这种转变放在计算机发展史的维度来看，它像极了从 <strong>汇编语言</strong> 到 <strong>高级语言</strong> 的进化，或者从 <strong>过程式脚本</strong> 到 <strong>面向对象编程</strong> 的范式转移。</p><figure><img src="`+l+'" alt="Prompt vs Skill Evolution" tabindex="0" loading="lazy"><figcaption>Prompt vs Skill Evolution</figcaption></figure><ul><li><strong>Prompt</strong> 是脆弱的脚本。它是线性的，依赖运气的。</li><li><strong>Skill</strong> 是稳固的对象。它是封装的，可复用的，有确定性的。</li></ul><p>我们正在经历一场从“自然语言交互”到“结构化指令交互”的认知升级。</p><p>你不再是在和一个聊天机器人闲聊，你是在<strong>调用 API</strong>。只不过这个 API 的内核是 LLM，参数是自然语言，返回值是高质量的交付物。</p><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>不要再沉迷于收集那些所谓的“神级 Prompt”了。</p><p>那是在捡芝麻。</p><p>去构建属于你自己的 <strong>Skill Library</strong>。把你的工作流、你的审美、你的红线，固化成一个个可调用的模块。这才是 AI 时代属于你个人的<strong>核心资产</strong>。</p><p>工具会变，模型会变，但你<strong>定义问题</strong>和<strong>封装世界</strong>的能力，才是不可替代的。</p><hr><p><em>END</em></p>',43)])])}const c=a(r,[["render",p]]),g=JSON.parse('{"path":"/insights/custom-writing-skills-tutorial.html","title":"提示词工程已死？Agent Skills 才是未来","lang":"zh-CN","frontmatter":{"title":"提示词工程已死？Agent Skills 才是未来","date":"2026-01-25T00:00:00.000Z","category":"工具","tag":["AI","Tools","Thinking"],"cover":"/covers/insights/prompt-engineering-is-dead.png","description":"提示词工程已死？Agent Skills 才是未来 2023 年，\\"Prompt Engineering\\"（提示词工程）一度被奉为 AI 时代的必修课。那时候，我们像炼丹师一样，试图通过修改一个标点、调整一段语序，来祈求模型输出完美的结果。 但到了 2026 年的今天，这种做法显得越来越笨重，甚至有些不可持续。 仔细观察会发现，我们陷入了一个误区：我们...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"提示词工程已死？Agent Skills 才是未来\\",\\"image\\":[\\"https://sharebravery.com/covers/insights/prompt-engineering-is-dead.png\\"],\\"datePublished\\":\\"2026-01-25T00:00:00.000Z\\",\\"dateModified\\":\\"2026-02-10T05:16:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"不辞远\\",\\"url\\":\\"https://github.com/sharebravery\\"}]}"],["meta",{"property":"og:url","content":"https://sharebravery.com/insights/custom-writing-skills-tutorial.html"}],["meta",{"property":"og:site_name","content":"不辞远的分享"}],["meta",{"property":"og:title","content":"提示词工程已死？Agent Skills 才是未来"}],["meta",{"property":"og:description","content":"提示词工程已死？Agent Skills 才是未来 2023 年，\\"Prompt Engineering\\"（提示词工程）一度被奉为 AI 时代的必修课。那时候，我们像炼丹师一样，试图通过修改一个标点、调整一段语序，来祈求模型输出完美的结果。 但到了 2026 年的今天，这种做法显得越来越笨重，甚至有些不可持续。 仔细观察会发现，我们陷入了一个误区：我们..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://sharebravery.com/covers/insights/prompt-engineering-is-dead.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-10T05:16:30.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://sharebravery.com/covers/insights/prompt-engineering-is-dead.png"}],["meta",{"name":"twitter:image:alt","content":"提示词工程已死？Agent Skills 才是未来"}],["meta",{"property":"article:tag","content":"Thinking"}],["meta",{"property":"article:tag","content":"Tools"}],["meta",{"property":"article:tag","content":"AI"}],["meta",{"property":"article:published_time","content":"2026-01-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-10T05:16:30.000Z"}]]},"git":{"createdTime":1769442692000,"updatedTime":1770700590000,"contributors":[{"name":"sharebravery","username":"sharebravery","email":"sharebravery@gmail.com","commits":5,"url":"https://github.com/sharebravery"},{"name":"Claude Sonnet 4.5","username":"","email":"noreply@anthropic.com","commits":2}]},"readingTime":{"minutes":4.34,"words":1303},"filePathRelative":"insights/custom-writing-skills-tutorial.md","excerpt":"\\n<p>2023 年，\\"Prompt Engineering\\"（提示词工程）一度被奉为 AI 时代的必修课。那时候，我们像炼丹师一样，试图通过修改一个标点、调整一段语序，来祈求模型输出完美的结果。</p>\\n<p>但到了 2026 年的今天，这种做法显得越来越笨重，甚至有些<strong>不可持续</strong>。</p>\\n<p>仔细观察会发现，我们陷入了一个误区：我们花费大量精力去“适应”机器，试图用自然语言去模拟机器的逻辑。一旦模型更新，或者上下文环境改变，那些精心调教的 Prompt 往往会瞬间失效。</p>\\n<p>这不叫工程，这叫<strong>碰运气</strong>。</p>\\n<p>真正的未来，或许不在于写出更完美的 Prompt，而在于构建更稳健的 <strong>Skills (技能)</strong>。</p>","autoDesc":true}');export{c as comp,g as data};
